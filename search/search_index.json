{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dataclasses Avro Schema Generator","text":"<p>Generate Avro Schemas from a Python class</p> <p>   </p>"},{"location":"#requirements","title":"Requirements","text":"<p><code>python 3.7+</code></p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install dataclasses-avroschema\n</code></pre> <p>or with <code>pydantic</code> funcionalities</p> <pre><code>pip install dataclasses-avroschema[pydantic]\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#generating-the-avro-schema","title":"Generating the avro schema","text":"Trival Usage<pre><code>import enum\nimport typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass FavoriteColor(enum.Enum):\n    BLUE = \"Blue\"\n    YELLOW = \"Yellow\"\n    GREEN = \"Green\"\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"An User\"\n    name: str\n    age: int\n    pets: typing.List[str]\n    accounts: typing.Dict[str, int]\n    favorite_color: FavoriteColor\n    country: str = \"Argentina\"\n    address: str = None\n\n    class Meta:\n        namespace = \"User.v1\"\n        aliases = [\"user-v1\", \"super user\"]\n\n\nUser.avro_schema()\n\n'{\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"doc\": \"An User\",\n    \"namespace\": \"User.v1\",\n    \"aliases\": [\"user-v1\", \"super user\"],\n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\"},\n        {\"name\": \"age\", \"type\": \"long\"},\n        {\"name\": \"pets\", \"type\": \"array\", \"items\": \"string\"},\n        {\"name\": \"accounts\", \"type\": \"map\", \"values\": \"long\"},\n        {\"name\": \"favorite_color\", \"type\": {\"type\": \"enum\", \"name\": \"FavoriteColor\", \"symbols\": [\"Blue\", \"Yellow\", \"Green\"]}}\n        {\"name\": \"country\", \"type\": \"string\", \"default\": \"Argentina\"},\n        {\"name\": \"address\", \"type\": [\"null\", \"string\"], \"default\": null}\n    ]\n}'\n\nUser.avro_schema_to_python()\n\n{\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"doc\": \"An User\",\n    \"namespace\": \"User.v1\",\n    \"aliases\": [\"user-v1\", \"super user\"],\n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\"},\n        {\"name\": \"age\", \"type\": \"long\"},\n        {\"name\": \"pets\", \"type\": {\"type\": \"array\", \"items\": \"string\", \"name\": \"pet\"}},\n        {\"name\": \"accounts\", \"type\": {\"type\": \"map\", \"values\": \"long\", \"name\": \"account\"}},\n        {\"name\": \"favorite_color\", \"type\": {\"type\": \"enum\", \"name\": \"FavoriteColor\", \"symbols\": [\"BLUE\", \"YELLOW\", \"GREEN\"]}},\n        {\"name\": \"country\", \"type\": \"string\", \"default\": \"Argentina\"},\n        {\"name\": \"address\", \"type\": [\"null\", \"string\"], \"default\": None}\n    ],\n}\n</code></pre>"},{"location":"avro_schema/","title":"Avro Schema and Python Classes","text":""},{"location":"avro_schema/#avro-schemas-and-python-class","title":"Avro Schemas and Python Class","text":""},{"location":"avro_schema/#what-is-apache-avro","title":"What is Apache Avro?","text":"<p>Avro is a row-oriented remote procedure call and data serialization framework developed within Apache's Hadoop project. It uses JSON for defining data types and protocols, and serializes data in a compact binary format. Avro uses a <code>schema</code> to structure the data that is being encoded. It has two different types of schema languages; one for human editing <code>(Avro IDL)</code> and another which is more machine-readable based on <code>(JSON)</code></p>"},{"location":"avro_schema/#goal","title":"Goal","text":"<p>Our goal is to come up with an <code>avro schema</code> from <code>Python classes</code>. We can think a <code>avro Record</code> as an analogous to a <code>python class</code>, but first, let's explaine what a <code>record</code> is.</p>"},{"location":"avro_schema/#records","title":"Records","text":"<p>Records are one of the <code>Complex Types</code> in avro. It use the type name <code>record</code> and support three attributes.</p> <ul> <li>name: a JSON string providing the name of the record (required).</li> <li>namespace: a JSON string that qualifies the name;</li> <li>doc: a JSON string providing documentation to the user of this schema (optional).</li> <li>aliases: a JSON array of strings, providing alternate names for this record (optional).</li> <li>fields: a JSON array, listing fields (required). Each field is a JSON object with the following attributes:<ul> <li>name: a JSON string providing the name of the field (required), and</li> <li>doc: a JSON string describing this field for users (optional).</li> <li>type: A JSON object defining a schema, or a JSON string naming a record definition (required).</li> <li>default: A default value for this field, used when reading instances that lack this field (optional). Permitted    values depend on the field's schema type, according to the table below. Default values for union fields correspond to the first schema in the union. Default values for bytes and fixed fields are JSON strings, where Unicode code points 0-255 are mapped to unsigned 8-bit byte values 0-255.</li> <li>order: specifies how this field impacts sort ordering of this record (optional). Valid values are \"ascending\" (the default), \"descending\", or \"ignore\". For more details on how this is used, see the the sort order section below.</li> <li>aliases: a JSON array of strings, providing alternate names for this field (optional).</li> </ul> </li> </ul> <p>For example, a User may be defined with:</p> <pre><code>{\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"fields\" : [\n        {\"name\": \"name\", \"type\": \"string\"},\n        {\"name\": \"age\", \"type\": \"int\"},\n        {\"name\": \"has_pets\", \"type\": \"boolean\"},\n        {\"name\": \"money\", \"type\": \"float\"}\n    ]\n}\n</code></pre>"},{"location":"avro_schema/#from-a-python-class-to-the-avro-schema","title":"From a Python class to the Avro Schema","text":"<p>Image that you have to define the previous <code>User</code> schema but you do not know avro, you know python:</p> Generate the avro schema from a class<pre><code>import dataclasses\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    name: str\n    age: int\n    has_pets: bool\n    money: float\n\nUser.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"has_pets\", \"type\": \"boolean\"},\n    {\"name\": \"money\", \"type\": \"float\"}\n  ],\n  \"doc\": \"User(name: str, age: int, has_pets: bool, money: float)\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>or create a python dictionary</p> Avro schema to python<pre><code>User.avro_schema_to_python()\n\n{\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"doc\": \"An User\",\n    \"namespace\": \"User.v1\",\n    \"aliases\": [\"user-v1\", \"super user\"],\n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\"},\n        {\"name\": \"age\", \"type\": \"long\"},\n        {\"name\": \"pets\", \"type\": {\"type\": \"array\", \"items\": \"string\", \"name\": \"pet\"}},\n        {\"name\": \"accounts\", \"type\": {\"type\": \"map\", \"values\": \"long\", \"name\": \"account\"}},\n        {\"name\": \"favorite_color\", \"type\": {\"type\": \"enum\", \"name\": \"favorite_color\", \"symbols\": [\"BLUE\", \"YELLOW\", \"GREEN\"]}},\n        {\"name\": \"country\", \"type\": \"string\", \"default\": \"Argentina\"},\n        {\"name\": \"address\", \"type\": [\"null\", \"string\"], \"default\": None}\n    ],\n}\n</code></pre> <p>and that is it!! Each python field is related with a avro type. You can find the field relationships here:</p>"},{"location":"case/","title":"Case schemas","text":"<p>Sometimes we use <code>avro schemas</code> with different sources (some written in Scala, some in Python, etc). With the <code>case</code> you can generate your schemas according to your programming language convention:</p> Example with CAPITALCASE<pre><code>import typing\nimport dataclasses\nimport enum\n\nfrom dataclasses_avroschema import AvroModel, case, types\n\n\n# New enum!!\nclass FavoriteColor(enum.Enum):\n    BLUE = \"BLUE\"\n    YELLOW = \"YELLOW\"\n    GREEN = \"GREEN\"\n\n\n@dataclasses.dataclass\nclass UserAdvance(AvroModel):\n    name: str\n    age: int\n    pets: typing.List[str]\n    accounts: typing.Dict[str, int]\n    favorite_colors: FavoriteColor\n    has_car: bool = False\n    country: str = \"Argentina\"\n    address: str = None\n    md5: types.Fixed = types.Fixed(16)\n\n    class Meta:\n        schema_doc = False\n\n\nUserAdvance.avro_schema(case_type=case.CAPITALCASE)\n</code></pre> <p>resulting in</p> <pre><code>{\n    \"type\": \"record\", \n    \"name\": \"UserAdvance\", \n    \"fields\": [\n        {\"name\": \"Name\", \"type\": \"string\"},\n        {\"name\": \"Age\", \"type\": \"long\"},\n        {\"name\": \"Pets\", \"type\": {\n            \"type\": \"array\", \"items\": \"string\", \"name\": \"Pet\"\n            }\n        },\n        {\"name\": \"Accounts\", \"type\": {\n            \"type\": \"map\", \"values\": \"long\", \"name\": \"Account\"\n            }\n        },\n        {\"name\": \"Has_car\", \"type\": \"boolean\", \"default\": false},\n        {\"name\": \"Favorite_colors\", \"type\": {\n            \"type\": \"enum\", \"name\": \"FavoriteColor\", \"symbols\": [\"BLUE\", \"YELLOW\", \"GREEN\"]\n            }\n        },\n        {\"name\": \"Country\", \"type\": \"string\", \"default\": \"Argentina\"},\n        {\"name\": \"Address\", \"type\": [\"null\", \"string\"], \"default\": null},\n        {\"name\": \"Md5\", \"type\": {\"type\": \"fixed\", \"name\": \"Md5\", \"size\": 16}}\n    ]\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>  <p>Note</p> <p>Cases do not apply to <code>records</code> and <code>enums</code> names as they are always expressed in <code>PascalCase</code></p>"},{"location":"case/#available-cases","title":"Available cases","text":"Case Example     camelcase 'foo_bar_baz' # =&gt; \"fooBarBaz\"   capitalcase 'foo_bar_baz' # =&gt; \"Foo_bar_baz\"   constcase 'FooBarBaz' # =&gt; \"_FOO_BAR_BAZ\"   lowercase 'FooBarBaz' # =&gt; \"foobarbaz\"   pascalcase 'FooBarBaz' # =&gt; \"FooBarBaz\"   pathcase 'foo_bar_baz' # =&gt; \"foo/bar/baz\"   snakecase 'FooBarBaz' # =&gt; \"foo_bar_baz\"   spinalcase 'FooBarBaz' # =&gt; \"-foo-bar-baz\"   trimcase 'FooBarBaz' # =&gt; \"FooBarBaz\"   uppercase 'FooBarBaz' # =&gt; \"FOOBARBAZ   alphanumcase 'Foo_123 Bar!' # =&gt;'Foo123Bar'"},{"location":"complex_types/","title":"Complex Types","text":"<p>The following list represent the avro complex types mapped to python types:</p>    Avro Type Python Type     enums enum.Enum   arrays typing.List, typing.Tuple, typing.Sequence, typing.MutableSequence   maps typing.Dict, typing.Mapping, typing.MutableMapping   fixed types.Fixed   unions typing.Union   unions with <code>null</code> typing.Optional   records Python Class"},{"location":"complex_types/#enums","title":"Enums","text":"Enum example<pre><code>import enum\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass FavoriteColor(enum.Enum):\n    BLUE = \"Blue\"\n    YELLOW = \"Yellow\"\n    GREEN = \"Green\"\n\n    class Meta:\n        doc = \"A favorite color\"\n        namespace = \"some.name.space\"\n        aliases = [\"Color\", \"My favorite color\"]\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"An User\"\n    favorite_color: FavoriteColor = FavoriteColor.BLUE\n\n\nUser.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\":\n  [\n    {\n      \"name\": \"favorite_color\",\n      \"type\":\n      {\n        \"type\": \"enum\",\n        \"name\": \"FavoriteColor\",\n        \"symbols\":\n        [\n          \"Blue\",\n          \"Yellow\",\n          \"Green\"\n        ],\n        \"doc\": \"A favorite color\",\n        \"namespace\": \"some.name.space\",\n        \"aliases\":\n        [\"Color\", \"My favorite color\"]\n      },\n      \"default\": \"Blue\"\n    }\n  ],\n  \"doc\": \"An User\"\n}'\n</code></pre>"},{"location":"complex_types/#repeated-enums","title":"Repeated Enums","text":"<p>Sometimes we have cases where an <code>Enum</code> is used more than once with a particular class, for those cases, you <code>MUST</code> define the namespace in order to generate a valid <code>avro schema</code></p> <pre><code>import enum\nimport dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass TripDistance(enum.Enum):\n    CLOSE = \"Close\"\n    FAR = \"Far\"\n\n    class Meta:\n        doc = \"Distance of the trip\"\n        namespace = \"trip\"\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    trip_distance: TripDistance\n    optional_distance: typing.Optional[TripDistance] = None\n\n\nprint(User.avro_schema())\n</code></pre> <p>resulting in</p> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\n      \"name\": \"trip_distance\",\n      \"type\": {\n        \"type\": \"enum\",\n        \"name\": \"TripDistance\",\n        \"symbols\": [\n          \"Close\",\n          \"Far\"\n        ],\n        \"doc\": \"Distance of the trip\",\n        \"namespace\": \"trip\"\n      }\n    },\n    {\n      \"name\": \"optional_distance\",\n      \"type\": [\n        \"null\",\n        \"trip.TripDistance\"\n      ],\n      \"default\": null\n    }\n  ],\n  \"doc\": \"User(trip_distance: __main__.TripDistance, optional_distance: Optional[__main__.TripDistance] = None)\"\n}\n</code></pre>  <p>Warning</p> <p>If you do not specify the <code>namespace</code> in the <code>Enum</code> the exception <code>NameSpaceRequiredException</code> is raised</p>"},{"location":"complex_types/#arrays","title":"Arrays","text":"Array example<pre><code>import dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass UserAdvance(AvroModel):\n    \"User advanced\"\n    pets: typing.List[str]\n    cars: typing.List[str] = None\n    favourites_numbers: typing.List[int] = dataclasses.field(default_factory=lambda: [7, 13])\n\n\nUserAdvance.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"UserAdvance\",\n  \"fields\": [\n    {\n      \"name\": \"pets\",\n      \"type\": {\n        \"type\": \"array\",\n        \"items\": \"string\",\n        \"name\": \"pet\"\n      }\n    },\n    {\n      \"name\": \"cars\",\n      \"type\": {\n        \"type\": \"array\",\n        \"items\": \"string\",\n        \"name\": \"car\"\n      },\n      \"default\": []\n    },\n    {\n      \"name\": \"favourites_numbers\",\n      \"type\": {\n        \"type\": \"array\",\n        \"items\": \"long\",\n        \"name\": \"favourites_number\"\n      },\n      \"default\": [7, 13]\n    }\n  ],\n  \"doc\": \"User advanced\"\n}'\n</code></pre>"},{"location":"complex_types/#maps","title":"Maps","text":"Map example<pre><code>import dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass UserAdvance(AvroModel):\n    \"User advanced\"\n    accounts_money: typing.Dict[str, float]\n    cars_brand_total: typing.Dict[str, int] = None\n    family_ages: typing.Dict[str, int] = dataclasses.field(default_factory=lambda: {\"father\": 50})\n\nUserAdvance.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"UserAdvance\",\n  \"fields\": [\n    {\n      \"name\": \"accounts_money\",\n      \"type\": {\n        \"type\": \"map\",\n        \"values\": \"float\",\n        \"name\": \"accounts_money\"\n      }\n    },\n    {\n      \"name\": \"cars_brand_total\",\n      \"type\": {\n        \"type\": \"map\",\n        \"values\": \"long\",\n        \"name\": \"cars_brand_total\"\n      },\n      \"default\": {}\n    },\n    {\n      \"name\": \"family_ages\",\n      \"type\": {\n        \"type\": \"map\",\n        \"values\": \"long\",\n        \"name\": \"family_age\"\n      },\n      \"default\": {\"father\": 50}\n    }\n  ],\n  \"doc\": \"User advanced\"\n}'\n</code></pre>"},{"location":"complex_types/#fixed","title":"Fixed","text":"Fixed example<pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel, types\n\n\n@dataclasses.dataclass\nclass UserAdvance(AvroModel):\n    name: str\n    md5: types.Fixed = types.Fixed(16, namespace='md5', aliases=[\"md5\", \"hash\"])\n\nUnionSchema.avro_schema()\n\n{\n  'type': 'record',\n  'name': 'UserAdvance',\n  'fields': [\n    {'name': 'name', 'type': 'string'},\n    {'name': 'md5', 'type': {'type': 'fixed', 'name': 'md5', 'size': 16,'namespace': 'md5', 'aliases': ['md5', 'hash']}}\n  ],\n  'doc': 'UserAdvance(name: str, md5: dataclasses_avroschema.types.Fixed = 16)'}\n</code></pre>"},{"location":"complex_types/#unions","title":"Unions","text":"python &lt;= 3.9python3.10   <pre><code>import typing\nimport dataclasses\nimport datetime\nimport uuid\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass UnionSchema(AvroModel):\n    \"Some Unions\"\n    first_union: typing.Union[str, int]\n    logical_union: typing.Union[datetime.datetime, datetime.date, uuid.uuid4]\n    second_union: typing.Union[str, int] = \"test\"\n    third_union: typing.Union[int, str] = 'STRING TYPE'\n\nUnionSchema.avro_schema()\n</code></pre>   <pre><code>import typing\nimport dataclasses\nimport datetime\nimport uuid\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass UnionSchema(AvroModel):\n    \"Some Unions\"\n    first_union: str | int\n    logical_union: datetime.datetime | datetime.date | uuid.uuid\n    second_union: str | int = \"test\"\n    third_union: int | str = 'STRING TYPE'\n\nUnionSchema.avro_schema()\n</code></pre>    result<pre><code>{\n  \"type\": \"record\",\n  \"name\": \"UnionSchema\",\n  \"fields\": [\n  {\"name\": \"first_union\", \"type\": [\"string\", \"long\"]},\n  {\"name\": \"logical_union\", \"type\": [\n    {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"},\n    {\"type\": \"long\", \"logicalType\": \"date\"},\n    {\"type\": \"string\", \"logicalType\": \"uuid\"}]},\n  {\"name\": \"second_union\", \"type\": [\"string\", \"long\"], \"default\": \"test\"},\n  {\"name\": \"third_union\", \"type\": [\"string\", \"long\"], \"default\": \"STRING TYPE\"}],\n  \"doc\": \"Some Unions\"\n}\n</code></pre>"},{"location":"complex_types/#union-with-records","title":"Union with Records","text":"python &lt;= 3.9python3.10   <pre><code>import dataclasses\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Bus(AvroModel):\n    \"A Bus\"\n    engine_name: str\n\n    class Meta:\n        namespace = \"types\"\n\n\n@dataclasses.dataclass\nclass Car(AvroModel):\n    \"A Car\"\n    engine_name: str\n\n    class Meta:\n        namespace = \"types\"\n\n\n@dataclasses.dataclass\nclass UnionSchema(AvroModel):\n  \"Some Unions\"\n  lake_trip: typing.Union[Bus, Car]\n  river_trip: typing.Union[Bus, Car] = None\n  mountain_trip: typing.Union[Bus, Car] = dataclasses.field(\n      default_factory=lambda: {\"engine_name\": \"honda\"})\n\nUnionSchema.avro_schema()\n</code></pre>   <pre><code>import dataclasses\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Bus(AvroModel):\n    \"A Bus\"\n    engine_name: str\n\n    class Meta:\n        namespace = \"types\"\n\n\n@dataclasses.dataclass\nclass Car(AvroModel):\n    \"A Car\"\n    engine_name: str\n\n    class Meta:\n        namespace = \"types\"\n\n\n@dataclasses.dataclass\nclass UnionSchema(AvroModel):\n  \"Some Unions\"\n  lake_trip: Bus | Car\n  river_trip: Bus | Car | None = None\n  mountain_trip: Bus | Car = dataclasses.field(\n      default_factory=lambda: {\"engine_name\": \"honda\"})\n\nUnionSchema.avro_schema()\n</code></pre>    result<pre><code>{\n  \"type\": \"record\",\n  \"name\": \"UnionSchema\",\n  \"fields\": [\n    {\n      \"name\": \"lake_trip\",\n      \"type\": [\n        {\n          \"type\": \"record\",\n          \"name\": \"Bus\",\n          \"fields\": [\n            {\n              \"name\": \"engine_name\",\n              \"type\": \"string\"\n            }\n          ],\n          \"doc\": \"A Bus\"\n        },\n        {\n          \"type\": \"record\",\n          \"name\": \"Car\",\n          \"fields\": [\n            {\n              \"name\": \"engine_name\",\n              \"type\": \"string\"\n            }\n          ],\n          \"doc\": \"A Car\"\n        }\n      ]\n    },\n    {\n      \"name\": \"river_trip\",\n      \"type\": [\n        \"null\",\n        \"types.Bus\",\n        \"types.Car\"\n      ]\n      \"default\": null\n    },\n    {\n      \"name\": \"mountain_trip\",\n      \"type\": [\n        \"types.Bus\",\n        \"types.Car\"\n      ],\n      \"default\": {\"engine_name\": \"honda\"}\n    }\n  ],\n  \"doc\": \"Some Unions\"\n}\n</code></pre>  <p>Note</p> <p>From python 3.10 you can use union type expressions using the <code>|</code> operator</p>"},{"location":"complex_types/#unions-with-typingoptional","title":"Unions with typing.Optional","text":"<p><code>typing.Optional[Any]</code> is translated as an optional Union: <code>typing.Union[Any, NoneType]</code> where <code>NoneType</code> is always at the end</p> python &lt;= 3.9python3.10   <pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\nfrom dataclasses import dataclass, field\n\n\n@dataclasses.dataclass\nclass X(AvroModel):\n    y: typing.Optional[typing.List[int]]\n\n\nX.avro_schema()\n</code></pre>   <pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\nfrom dataclasses import dataclass, field\n\n\n@dataclasses.dataclass\nclass X(AvroModel):\n    y: typing.List[int] | None\n\n\nX.avro_schema()\n</code></pre>    result<pre><code>{\n    \"type\": \"record\",\n    \"name\": \"X\",\n    \"fields\": [\n        {\"name\": \"y\", \"type\": [{\"type\": \"array\", \"items\": \"long\", \"name\": \"y\"}, \"null\"]}\n    ],\n    \"doc\": \"X(y: Union[List[int], NoneType])\"\n}\n</code></pre>"},{"location":"factories_and_fixtures/","title":"Factories and Fixtures","text":"<p>Dataclasses Avro Schema also includes a <code>factory</code> feature, so you can generate <code>fast</code> python instances and use them, for example, to test your data streaming pipelines. Instances can be genrated using the <code>fake</code> method.</p> Basic usage<pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    addresses: typing.List[Address]\n\n\nAddress.fake()\n# &gt;&gt;&gt;&gt; Address(street='PxZJILDRgbXyhWrrPWxQ', street_number=2067)\n\nUser.fake()\n# &gt;&gt;&gt;&gt; User(name='VGSBbOGfSGjkMDnefHIZ', age=8974, addresses=[Address(street='vNpPYgesiHUwwzGcmMiS', street_number=4790)])\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"factories_and_fixtures/#pydantic-fixtures","title":"Pydantic fixtures","text":"<p>It is also possible to generate fixtures with the <code>pydantic integration</code> simply using <code>AvroBaseModel</code>:</p> <pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema.avrodantic import AvroBaseModel\n\n\nclass Address(AvroBaseModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\nclass User(AvroBaseModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    address: typing.Optional[Address] = None\n\n\nAddress.fake()\n# &gt;&gt;&gt;&gt; Address(street='PxZJILDRgbXyhWrrPWxQ', street_number=2067)\n\nUser.fake()\n# &gt;&gt;&gt;&gt; User(name='MCyzAtufQSwjxwCOmIBV', age=4377, address=Address(street='fUQfMHpvxsfmBDcaWJxb', street_number=722))\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"factories_and_fixtures/#providing-data-to-the-factory","title":"Providing data to the factory","text":"<p>It is also possible to provide data as <code>keyword arguments</code> to the factory using the <code>fake</code> method.</p> <pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass UserAdvance(AvroModel):\n    name: str\n    age: int\n    pets: typing.List[str]\n    accounts: typing.Dict[str, int]\n    has_car: bool = False\n    country: str = \"Argentina\"\n    address: typing.Optional[str] = None\n\n\nuser = UserAdvance.fake(name=\"bond\", age=50, pets=[\"dog\", \"cat\"])\nassert user.name == \"bond\"\nassert user.age == 50\nassert user.pets == [\"dog\", \"cat\"]\n\nprint(user)\n# &gt;&gt;&gt;&gt; UserAdvance(name='bond', age=50, pets=['dog', 'cat'], accounts={'uVITaqdTStKhsdHFqIdM': 4201}, has_car=True, country='cirJWyuMaXoBqEmxbdML', address='qGhXKxAFfIxzAMZdkhrk')\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"faust_records/","title":"Faust Records","text":"<p>This library also has support to generate <code>Avro Schemas</code> from a <code>faust.Record</code></p> <p>Example:</p> Basic usage<pre><code>import faust\nimport dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass UserAdvance(faust.Record, AvroModel):\n    name: str\n    age: int\n    pets: typing.List[str] = dataclasses.field(default_factory=lambda: ['dog', 'cat'])\n    accounts: typing.Dict[str, int] = dataclasses.field(default_factory=lambda: {\"key\": 1})\n    has_car: bool = False\n    favorite_colors: typing.Tuple[str] = (\"BLUE\", \"YELLOW\", \"GREEN\")\n    country: str = \"Argentina\"\n    address: str = None\n\n    class Meta:\n        schema_doc = False\n\n\nUserAdvance.avro_schema()\n</code></pre> <p>resulting in </p> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"UserAdvance\",\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"age\",\n      \"type\": \"long\"\n    },\n    {\n      \"name\": \"pets\",\n      \"type\": {\n        \"type\": \"array\",\n        \"items\": \"string\",\n        \"name\": \"pet\"\n      },\n      \"default\": [\"dog\", \"cat\"]\n    },\n    {\n      \"name\": \"accounts\",\n      \"type\": {\n        \"type\": \"map\",\n        \"values\": \"long\",\n        \"name\": \"account\"\n      },\n      \"default\": {\"key\": 1}\n    },\n    {\n      \"name\": \"has_car\",\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    {\n      \"name\": \"favorite_colors\", \n      \"type\": {\n        \"type\": \"array\", \"items\": \"string\", \"name\": \"favorite_color\"\n      }\n    },\n    {\n      \"name\": \"country\",\n      \"type\": \"string\",\n      \"default\": \"Argentina\"\n    },\n    {\n      \"name\": \"address\",\n      \"type\": [\"null\", \"string\"],\n      \"default\": null\n    }\n  ]\n}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"fields_specification/","title":"Fields Specification","text":"<p>Apache Avro has <code>Primitive Types</code>, <code>Complex Types</code> and <code>Logical Types</code>, so we need to match these types with python types.</p>"},{"location":"fields_specification/#primitive-types-and-python-representation","title":"Primitive Types and python representation","text":"<p>The set of primitive type names is:</p> <ul> <li>null: no value</li> <li>boolean: a binary value</li> <li>int: 32-bit signed integer</li> <li>long: 64-bit signed integer</li> <li>float: single precision (32-bit) IEEE 754 floating-point number</li> <li>double: double precision (64-bit) IEEE 754 floating-point number</li> <li>bytes: sequence of 8-bit unsigned bytes</li> <li>string: unicode character sequence</li> </ul> <p>So, the previous types can be matched to:</p>    Avro Type Python Type     string str   long int   boolean bool   double float   null None   bytes bytes   int types.Int32   float types.Float32    <p>Since Python does not have native <code>int32</code> or <code>float32</code> types, use the <code>dataclasses_avroschema.types.Int32</code> and <code>dataclasses_avroschema.types.Float32</code> types to annotate your classes. These types are simple wrappers around Python's default <code>int</code> and <code>float</code> types.</p>"},{"location":"fields_specification/#complex-types","title":"Complex Types","text":"<p>Avro supports six kinds of complex types: enums, arrays, maps, fixed, unions and records.</p>    Avro Type Python Type     enums tuple   arrays list   maps dict   fixed types.Fixed   unions typing.Union   records Python Class    <ul> <li>Enums: Use the type name \"enum\" and support the following attributes:</li> <li>name: a JSON string providing the name of the enum (required).</li> <li>namespace: a JSON string that qualifies the name;</li> <li>aliases: a JSON array of strings, providing alternate names for this enum (optional).</li> <li>doc: a JSON string providing documentation to the user of this schema (optional).</li> <li>symbols: a JSON array, listing symbols, as JSON strings (required). All symbols in an enum must be unique; duplicates are prohibited. Every symbol must match the regular expression [A-Za-z_][A-Za-z0-9_]* (the same requirement as for names).</li> </ul> <p>When we want to define a <code>enum</code> type we should specify a default value because we need to define the <code>symbols</code> In future version we will have a custom enum type to avoid this</p> <ul> <li>Arrays: Use the type name \"array\" and support the following attribute:</li> <li>name: a JSON string providing the name of the enum (required).</li> <li> <p>items: the schema of the array's items.</p> </li> <li> <p>Maps: Use the type name \"map\". Map keys are assumed to be string. Support the following attribute:</p> </li> <li>name: a JSON string providing the name of the enum (required).</li> <li> <p>values: the schema of the map's values.</p> </li> <li> <p>Fixed uses the type name \"fixed\" and supports two attributes:</p> </li> <li>name: a string naming this fixed (required).</li> <li>namespace, a string that qualifies the name;</li> <li>aliases: a JSON array of strings, providing alternate names for this enum (optional).</li> <li> <p>size: an integer, specifying the number of bytes per value (required).</p> </li> <li> <p>Unions: <code>Unions</code> are represented using JSON arrays. For example, <code>[\"null\", \"string\"]</code> declares a schema which may be either a null or string. Under the Avro specifications, if a union field as a default, the type of the default must be the first listed type in the array. Dataclasses-avroschema will automatically generate the appropriate array if a default is provided. Note that an optional field (typing.Optional[T]) generates the union <code>[T, null]</code>, where <code>T</code> is the first element in the union. <code>None</code> will need to be explicitly declared the default to generate the appropriate schema, if the default should be <code>None/null</code>.</p> </li> <li> <p>Records: <code>Records</code> use the type name <code>record</code> and will represent the <code>Schema</code>.</p> </li> </ul>"},{"location":"fields_specification/#logical-types","title":"Logical Types","text":"<p>A logical type is an Avro primitive or complex type with extra attributes to represent a derived type. The attribute logicalType must always be present for a logical type, and is a string with the name of one of the logical types listed later in this section. Other attributes may be defined for particular logical types.</p> <p>A logical type is always serialized using its underlying Avro type so that values are encoded in exactly the same way as the equivalent Avro type that does not have a logicalType attribute. Language implementations may choose to represent logical types with an appropriate native type, although this is not required.</p> <p>Language implementations must ignore unknown logical types when reading, and should use the underlying Avro type. If a logical type is invalid, for example a decimal with scale greater than its precision, then implementations should ignore the logical type and use the underlying Avro type.</p> <ul> <li> <p>Date: The date logical type represents a date within the calendar, with no reference to a particular time zone or time of day. A date logical type annotates an Avro int, where the int stores the number of days from the unix epoch, 1 January 1970 (ISO calendar).</p> </li> <li> <p>Time (millisecond precision): The time-millis logical type represents a time of day, with no reference to a particular calendar, time zone or date, with a precision of one millisecond. A time-millis logical type annotates an Avro int, where the int stores the number of milliseconds after midnight, 00:00:00.000.</p> </li> <li> <p>Timestamp (millisecond precision): The timestamp-millis logical type represents an instant on the global timeline, independent of a particular time zone or calendar, with a precision of one millisecond. A timestamp-millis logical type annotates an Avro long, where the long stores the number of milliseconds from the unix epoch, 1 January 1970 00:00:00.000 UTC.</p> </li> <li> <p>UUID: Represents a uuid as a string</p> </li> <li> <p>Decimal: Represents a decimal.Decimal as bytes</p> </li> </ul>    Avro Type Logical Type Python Type     int date datetime.date   int time-millis datetime.time   long time-micros types.TimeMicro   long timestamp-millis datetime.datetime   long timestamp-micros types.DateTimeMicro   string uuid uuid.uuid4   string uuid uuid.UUID   bytes decimal decimal.Decimal"},{"location":"fields_specification/#avro-field-and-python-types-summary","title":"Avro Field and Python Types Summary","text":"Python Type Avro Type Logical Type     str string do not apply   long int do not apply   bool boolean do not apply   double float do not apply   None null do not apply   bytes bytes do not apply   typing.List array do not apply   typing.Tuple array do not apply   typing.Sequence array do not apply   typing.MutableSequence array do not apply   typing.Dict map do not apply   typing.Mapping map do not apply   typing.MutableMapping map do not apply   types.Fixed fixed do not apply   enum.Enum enum do not apply   types.Int32 int do not apply   types.Float32 float do not apply   typing.Union union do not apply   typing.Optional union (with <code>null</code>) do not apply   Python class record do not apply   datetime.date int date   datetime.time int time-millis   types.TimeMicro long time-micros   datetime.datetime long timestamp-millis   types.DateTimeMicro long timestamp-micros   decimal.Decimal bytes decimal   uuid.uuid4 string uuid   uuid.UUID string uuid"},{"location":"fields_specification/#adding-custom-field-level-attributes","title":"Adding Custom Field-level Attributes","text":"<p>You may want to add field-level attributes which are not automatically populated according to the typing semantics listed above. For example, you might want a <code>\"doc\"</code> attribute or even a custom attribute (which Avro supports as long as it doesn't conflict with any field names in the core Avro specification). An example of a custom attribute is a flag for whether a field contains sensitive data. e.g. <code>\"sensitivty\"</code>.</p> <p>When your Python class is serialised to Avro, each field will contain a number of attributes. Some of these of are common to all fields such as <code>\"name\"</code> and others are specific to the datatype (e.g. <code>array</code> will have the <code>items</code> attribute). In order to add custom fields, you can use the <code>field</code> descriptor of the built-in <code>dataclasses</code> package and provide a <code>dict</code> of key-value pairs to the <code>metadata</code> parameter as in <code>dataclasses.field(metadata={'doc': 'foo'})</code>.</p>"},{"location":"fields_specification/#examples","title":"Examples","text":"Adding a doc attribute to fields<pre><code>from dataclasses import dataclass, field\nfrom dataclasses_avroschema import AvroModel, types\n\n@dataclass\nclass User(AvroModel):\n    \"An User\"\n    name: str = field(metadata={'doc': 'bar'})\n    age: int = field(metadata={'doc': 'foo'})\n\nUser.avro_schema()\n\n{\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"doc\": \"An User\",\n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\", \"doc\": \"bar\"},\n        {\"name\": \"age\", \"type\": \"long\", \"doc\": \"foo\"}\n    ]\n}\n</code></pre> Adding an additional sensitivity attribute to fields.<pre><code>from dataclasses import dataclass, field\nfrom dataclasses_avroschema import AvroModel, types\n\n@dataclass\nclass User(AvroModel):\n    \"An User\"\n    name: str = field(metadata={'doc': 'bar', 'sensitivity': 'HIGH'})\n    age: int = field(metadata={'doc': 'foo', 'sensitivity': 'MEDIUM'})\n\nUser.avro_schema()\n\n{\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"doc\": \"An User\",\n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\", \"doc\": \"bar\", \"sensitivity\": \"HIGH\"},\n        {\"name\": \"age\", \"type\": \"long\", \"doc\": \"foo\", \"sensitivity\": \"MEDIUM\"}\n    ]\n}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"good_practices/","title":"Good Practices","text":""},{"location":"good_practices/#streaming","title":"Streaming","text":""},{"location":"good_practices/#schema-server-and-avromodel","title":"Schema server and AvroModel","text":"<p>First, let's clarify what a schema server is: It is a <code>central place/repository</code> that contains schemas with formats like <code>avro</code>, <code>json</code> or <code>protobuf</code>, with the purpose of exposing them through an <code>API</code>, so applications can access them and <code>serialize/deserialize</code> events. The schema server could have a <code>RESTful</code> interface so tasks like <code>create</code>, <code>delete</code> <code>get</code> schemas can be performed easily. </p> <p>In a <code>pythonic world</code>, you wouldn't need a <code>schema server</code> because using only the <code>AvroModel</code> will be enough as all the teams in your organization will use the same models, but this is not always the case. Somethimes, in big companies teams use different programming languages to talk the streaming layer, like <code>python</code>, <code>java</code>, <code>go</code>, etc. In this sense, you need a way to share <code>schemas</code> and you will need a <code>schema server</code>, otherwise it will be really hard to maintain the whole proccess.</p> <p>If you have a <code>Schema Server</code> and you want to use <code>AvroModel</code>, I would recommend you to add the <code>schema_id</code> in the <code>Model.Meta</code> that matches the schema in the <code>schema server</code>:</p> Include schema_id in Meta<pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"My User Class\"\n    name: str\n    age: int\n    has_pets: bool = False\n    money: float = 100.3\n\n    class Meta:\n        schema_id = \"https://my-schema-server/users/schema.avsc\" # or in a Concluent way: https://my-schema-server/schemas/ids/{int: id}\n</code></pre> <p>The purpose of the <code>schema_id</code> is to give a fast notion what the model is representing. Also, could be used as <code>documentation</code></p>"},{"location":"good_practices/#include-event-metadata","title":"Include event metadata","text":"<p><code>avro schemas</code> are used widely in <code>streaming</code> to <code>serialize</code> events, and with <code>dataclasses-avroschemas</code> it is straigtforward. Once  that you have the event, it is a good practice to also add the <code>event metadata</code> at the moment of <code>producing</code> so <code>consumers</code> will know what to do.</p> <p>Event metadata:</p> <ul> <li><code>content-type</code> or <code>serialization-type</code>: represents the way that the event was serialized. This could be <code>avro</code> or <code>avro-json</code> for example.</li> <li><code>schema-id</code>: represents the <code>schema-id</code> that was used to serialize the event if exist.</li> </ul> Produce event with metadata<pre><code>import asyncio\nimport dataclasses\nfrom dataclasses_avroschema import AvroModel\nfrom aiokafka import AIOKafkaProducer\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"My User Class\"\n    name: str\n    age: int\n    has_pets: bool = False\n    money: float = 100.3\n\n    class Meta:\n        schema_id = \"https://my-schema-server/users/schema.avsc\" # or in a Concluent way: https://my-schema-server/schemas/ids/{int: id}\n\n\nasync def produce():\n    # Naive example of producing an event\n\n    producer = AIOKafkaProducer(bootstrap_servers='localhost:9092')\n    await producer.start()\n\n    user = User(\"Bond\", age=\"50\")\n\n    # create the event\n    event = user.serialize()\n    headers = [\n        (\"content-type\": b\"avro\"),\n        (\"schema-id\": User.Meta.schema_id.encode()),\n    ]\n\n    await producer.send_and_wait(\"my_topic\", value=event, headers=headers)\n    await producer.stop()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(produce)\n</code></pre>"},{"location":"kafka_examples/","title":"Kafka examples","text":"<p>Under examples folder you can find 3 differents examples, one with aiokafka (<code>async</code>) showing the simplest use case when a <code>AvroModel</code> instance is serialized and sent it thorught kafka, and the event is consumed. The other two examples are <code>sync</code> using the kafka-python driver, where the <code>avro-json</code> serialization and <code>schema evolution</code> (<code>FULL</code> compatibility) is shown.</p>"},{"location":"kafka_examples/#minimal-example","title":"Minimal example","text":"Example with aiokafka driver<pre><code>import asyncio\nimport enum\nfrom dataclasses import dataclass\nimport random\n\nfrom aiokafka import AIOKafkaConsumer, AIOKafkaProducer\n\nfrom dataclasses_avroschema import AvroModel\n\n\nclass FavoriteColor(enum.Enum):\n    BLUE = \"Blue\"\n    YELLOW = \"Yellow\"\n    GREEN = \"Green\"\n\n@dataclass\nclass UserModel(AvroModel):\n    \"An User\"\n    name: str\n    age: int\n    favorite_colors: FavoriteColor = FavoriteColor.BLUE\n    country: str = \"Argentina\"\n    address: str = None\n\n    class Meta:\n        namespace = \"User.v1\"\n        aliases = [\"user-v1\", \"super user\"]\n\n\nasync def consume(loop, total_events=10):\n    consumer = AIOKafkaConsumer(\n        'my_topic', 'my_other_topic',\n        loop=loop, bootstrap_servers='localhost:9092',\n        group_id=\"my-group\")\n    # Get cluster layout and join group `my-group`\n    await consumer.start()\n    run_consumer = True\n\n    while run_consumer:\n        try:\n            # Consume messages\n            async for msg in consumer:\n                print(f\"Message received: {msg.value} at {msg.timestamp}\")\n\n                user = UserModel.deserialize(msg.value)\n                print(f\"Message deserialized: {user}\")\n        except KeyboardInterrupt:\n            # Will leave consumer group; perform autocommit if enabled.\n            await consumer.stop()\n            print(\"Stoping consumer...\")\n            run_consumer = False\n\n\nasync def send(loop, total_events=10):\n    producer = AIOKafkaProducer(\n        loop=loop, bootstrap_servers='localhost:9092')\n    # Get cluster layout and initial topic/partition leadership information\n    await producer.start()\n\n    for event_number in range(1, total_events + 1):\n        # Produce message\n        print(f\"Sending event number {event_number}\")\n\n        user = UserModel(\n            name=random.choice([\"Juan\", \"Peter\", \"Michael\", \"Moby\", \"Kim\",]),\n            age=random.randint(1, 50)\n        )\n\n        # create the message\n        message = user.serialize()\n\n        await producer.send_and_wait(\"my_topic\", message)\n        # sleep for 2 seconds\n        await asyncio.sleep(2)\n    else:\n        # Wait for all pending messages to be delivered or expire.\n        await producer.stop()\n        print(\"Stoping producer...\")\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    tasks = asyncio.gather(send(loop), consume(loop))\n\n    loop.run_until_complete(tasks)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"logical_types/","title":"Logical Types","text":"<p>The following list represent the avro logical types mapped to python types:</p>    Avro Type Logical Type Python Type     int date datetime.date   int time-millis datetime.time   long time-micros types.TimeMicro   long timestamp-millis datetime.datetime   long timestamp-micros types.DateTimeMicro   string uuid uuid.uuid4   string uuid uuid.UUID   bytes decimal decimal.Decimal"},{"location":"logical_types/#date","title":"Date","text":"Date example<pre><code>import datetime\nimport dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\na_datetime = datetime.datetime(2019, 10, 12, 17, 57, 42)\n\n\n@dataclasses.dataclass\nclass DateLogicalType(AvroModel):\n    \"Date type\"\n    birthday: datetime.date\n    meeting_date: typing.Optional[datetime.date] = None\n    release_datetime: datetime.date = a_datetime.date()\n\n\nDateLogicalType.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"DateLogicalType\",\n  \"fields\": [\n    {\n      \"name\": \"birthday\",\n      \"type\": {\"type\": \"int\", \"logicalType\": \"date\"}},\n    {\n      \"name\": \"meeting_date\",\n      \"type\": [\"null\", {\"type\": \"int\", \"logicalType\": \"date\"}],\n      \"default\": null\n    },\n    {\n      \"name\": \"release_datetime\",\n      \"type\": {\"type\": \"int\", \"logicalType\": \"date\"},\n      \"default\": 18181\n    }\n  ],\n  \"doc\": \"Date type\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"logical_types/#time","title":"Time","text":"Time example<pre><code>import datetime\nimport dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel, TimeMicro\n\na_datetime = datetime.datetime(2019, 10, 12, 17, 57, 42)\n\n\n@dataclasses.dataclass\nclass TimeLogicalTypes(AvroModel):\n    \"Time logical types\"\n    birthday_time: datetime.time\n    meeting_time: typing.Optional[datetime.time] = None\n    release_time: datetime.time = a_datetime.time()\n    release_time_micro: TimeMicro = a_datetime.time()\n\nTimeLogicalTypes.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"TimeLogicalTypes\",\n  \"fields\": [\n    {\n      \"name\": \"birthday_time\",\n      \"type\": {\"type\": \"int\", \"logicalType\": \"time-millis\"}\n    },\n    {\n      \"name\": \"meeting_time\",\n      \"type\": [\"null\", {\"type\": \"int\", \"logicalType\": \"time-millis\"}],\n      \"default\": null\n    },\n    {\n      \"name\": \"release_time\",\n      \"type\": {\"type\": \"int\", \"logicalType\": \"time-millis\"},\n      \"default\": 64662000\n    },\n    {\n      \"name\": \"release_time_micro\",\n      \"type\": {\"type\": \"long\", \"logicalType\": \"time-micros\"},\n      \"default\": 64662000000\n    }\n  ],\n  \"doc\": \"Time logical types\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>  <p>To use <code>time-micros</code> in avro schemas you need to use <code>types.TimeMicro</code></p>"},{"location":"logical_types/#datetime","title":"Datetime","text":"DateTime example<pre><code>import datetime\nimport dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel, DateTimeMicro\n\na_datetime = datetime.datetime(2019, 10, 12, 17, 57, 42)\n\n\n@dataclasses.dataclass\nclass DatetimeLogicalType(AvroModel):\n    \"Datetime logical types\"\n    birthday: datetime.datetime\n    meeting_time: typing.Optional[datetime.datetime] = None\n    release_datetime: datetime.datetime = a_datetime\n    release_datetime_micro: DateTimeMicro = a_datetime\n\nDatetimeLogicalType.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"DatetimeLogicalType\",\n  \"fields\": [\n    {\n      \"name\": \"birthday\",\n      \"type\": {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}\n    },\n    {\n      \"name\": \"meeting_time\",\n      \"type\": [\"nul\", {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}],\n      \"default\": null\n    },\n    {\n      \"name\": \"release_datetime\",\n      \"type\": {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"},\n      \"default\": 1570903062000\n    },\n    {\n      \"name\": \"release_datetime_micro\",\n      \"type\": {\"type\": \"long\", \"logicalType\": \"timestamp-micros\"},\n      \"default\": 1570903062000000\n    }\n  ],\n  \"doc\": \"Datetime logical types\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>  <p>Note</p> <p>To use <code>timestamp-micros</code> in avro schemas you need to use <code>types.DateTimeMicro</code></p>"},{"location":"logical_types/#uuid","title":"UUID","text":"UUID example<pre><code>import uuid\nimport dataclasses\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass UUIDLogicalTypes(AvroModel):\n    \"UUID logical types\"\n    uuid_1: uuid.uuid4\n    uuid_2: typing.Optional[uuid.uuid4] = None\n    event_uuid: uuid.uuid4 = uuid.uuid4()\n\nUUIDLogicalTypes.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"UUIDLogicalTypes\",\n  \"fields\": [\n    {\n      \"name\": \"uuid_1\",\n      \"type\": {\"type\": \"string\", \"logicalType\": \"uuid\"}\n    },\n    {\n      \"name\": \"uuid_2\",\n      \"type\": [\"null\", {\"type\": \"string\", \"logicalType\": \"uuid\"}],\n      \"default\": null\n    },\n    {\n      \"name\": \"event_uuid\",\n      \"type\": {\"type\": \"string\", \"logicalType\": \"uuid\"},\n      \"default\": \"ad0677ab-bd1c-4383-9d45-e46c56bcc5c9\"\n    }\n  ],\n  \"doc\": \"UUID logical types\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"logical_types/#decimal","title":"Decimal","text":"<p>The below code shows an example on how to use decimals. There's a few important things to note: * A default IS REQUIRED in order to set scale and precision on the Avro schema * It is strongly recommended to set these explicitly using <code>types.Decimal(scale=, precision=)</code> * They can be set implicitly by using a default <code>decimal.Decimal</code> * If set implicitly, scale and precision will be derived from the default as follows: <pre><code>    default: decimal.Decimal = decimal.Decimal('3.14')\n    sign, digits, exp = default.as_tuple()\n    precision = len(digits)\n    scale = exp * -1  # Avro schema defines scale as a positive, as_tuple provides negative\n</code></pre> * This CAN and WILL have strange consequences if not careful, ESPECIALLY if constructing <code>decimal.Decimal</code> with a float. For example: <pre><code>    string_definition: decimal.Decimal = decimal.Decimal('3.14')\n    # scale = 2, precision = 3\n    float_definition: decimal.Decimal = decimal.Decimal(3.14)\n    # scale = 51, precision = 52\n</code></pre></p> Decimal example<pre><code>import decimal\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel, types\n\n\n@dataclasses.dataclass\nclass DecimalLogicalTypes(AvroModel):\n    \"Decimal logical types\"\n    explicit: decimal.Decimal = types.Decimal(scale=2, precision=3)\n    explicit_with_default: decimal.Decimal = types.Decimal(scale=2, precision=3, default=decimal.Decimal('3.14'))\n    implicit: decimal.Decimal = decimal.Decimal('3.14') # sets scale = 2, precision = 3, derived from provided default\n    # will_error: decimal.Decimal  # THIS WILL ERROR\nDecimalLogicalTypes.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"DecimalLogicalTypes\",\n  \"fields\": [\n    {\n      \"name\": \"explicit\",\n      \"type\": {\n        \"type\": \"bytes\",\n        \"logicalType\": \"decimal\",\n        \"precision\": 3,\n        \"scale\": 2\n      }\n    },\n    {\n      \"name\": \"explicit_with_default\",\n      \"type\": {\n        \"type\": \"bytes\",\n        \"logicalType\": \"decimal\",\n        \"precision\": 3,\n        \"scale\": 2\n      },\n      \"default\": \"\\\\u013a\"\n    },\n    {\n      \"name\": \"implicit\",\n      \"type\": {\n        \"type\": \"bytes\",\n        \"logicalType\": \"decimal\",\n        \"precision\": 3,\n        \"scale\": 2\n      },\n      \"default\": \"\\\\u013a\"\n    }\n  ],\n  \"doc\": \"Decimal logical types\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"migration_guide/","title":"Migration Guide","text":""},{"location":"migration_guide/#migration-from-previous-versions-to-0270","title":"Migration from previous versions to 0.27.0","text":"<ul> <li><code>types.Enum</code> was replaced with <code>enum.Enum</code>. You must create your custom enum, example:</li> </ul> <pre><code>import dataclasses\nfrom dataclasses_avroschema import AvroModel, types\n\n\nclass UserAdvance(AvroModel):\n    name: str\n    age: int\n    favorite_colors: types.Enum = types.Enum([\"BLUE\", \"YELLOW\", \"GREEN\"], default=\"BLUE\")  # --&gt; replace with field!!!\n</code></pre> <p>should be replaced by:</p> <pre><code>import enum\nimport dataclasses\nfrom dataclasses_avroschema import AvroModel\n\n\n# New enum!!\nclass FavoriteColor(enum.Enum):\n    BLUE = \"BLUE\"\n    YELLOW = \"YELLOW\"\n    GREEN = \"GREEN\"\n\n\nclass UserAdvance:\n    name: str\n    age: int\n    favorite_colors: FavoriteColor = FavoriteColor.BLUE  # --&gt; field updated!!!\n</code></pre>"},{"location":"migration_guide/#migration-from-previous-versions-to-0230","title":"Migration from previous versions to 0.23.0","text":"<ol> <li>Now the name for Nested record uses the <code>class.__name__</code> instead of <code>`class.__name__.lower()_record</code>.</li> </ol> <p>having this schemas:</p> <pre><code>class Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\nclass User(AvroModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    addresses: typing.Dict[str, Address]\n\n\n# PREVIOUS\nUser.avro_schema()\n{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"addresses\", \"type\": {\n        \"type\": \"map\",\n        \"values\": {\n          \"type\": \"record\",\n          \"name\": \"address_record\",\n          \"fields\": [\n            {\"name\": \"street\", \"type\": \"string\"},\n            {\"name\": \"street_number\", \"type\": \"long\"}\n          ],\n          \"doc\": \"An Address\"\n        },\n        \"name\": \"address\"\n      }\n    }\n  ],\n  \"doc\": \"User with multiple Address\"\n}\n\n\n# VERSIONS 0.23.0\nUser.avro_schema()\n{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"addresses\", \"type\": {\n        \"type\": \"map\",\n        \"values\": {\n          \"type\": \"record\",\n          \"name\": \"Address\",\n          \"fields\": [\n            {\"name\": \"street\", \"type\": \"string\"},\n            {\"name\": \"street_number\", \"type\": \"long\"}\n          ],\n          \"doc\": \"An Address\"\n        },\n        \"name\": \"address\"\n      }\n    }\n  ],\n  \"doc\": \"User with multiple Address\"\n}\n</code></pre> <ol> <li>Now we use <code>namespaces</code> when same types are referenced multiple times (DRY), so you MUST define the property <code>namespace</code>:</li> </ol> <pre><code>class Location(AvroModel):\n    latitude: float\n    longitude: float\n\n    class Meta:\n        namespace = \"types.location_type\"  # REQUIRED!!!!\n\nclass Trip(AvroModel):\n    start_time: datetime.datetime\n    start_location: Location\n    finish_time: datetime.datetime\n    finish_location: Location\n\nTrip.avro_schema_to_python()\n</code></pre> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"Trip\",\n  \"fields\": [\n    {\n      \"name\": \"start_time\",\n      \"type\": {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}\n    },\n    {\n      \"name\": \"start_location\",\n      \"type\": {\"type\": \"record\",\n      \"name\": \"Location\",\n        \"fields\": [\n          {\"name\": \"latitude\", \"type\": \"double\"},\n          {\"name\": \"longitude\", \"type\": \"double\"}\n        ],\n      \"doc\": \"Location(latitude: float, longitude: float)\",\n      \"namespace\": \"types.location_type\"}},\n    {\n      \"name\": \"finish_time\",\n      \"type\": {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}\n    },\n    {\n      \"name\": \"finish_location\", \"type\": \"types.location_type.Location\"  // using the namespace\n    }\n  ],\n  \"doc\": \"Trip(start_time: datetime.datetime, start_location: __main__.Location, finish_time: datetime.datetime, finish_location: __main__.Location)\"\n}\n</code></pre>"},{"location":"migration_guide/#migration-from-previous-versions-to-0140","title":"Migration from previous versions to 0.14.0","text":"<p>Now all the dataclasses should inheritance from <code>AvroModel</code> and not use anymore the <code>SchemaGenerator</code>:</p> <pre><code># Versions &lt; 0.14.0\n\nimport typing\n\nfrom dataclasses_avroschema import SchemaGenerator, types\n\n\nclass User:\n    \"An User\"\n    name: str\n    age: int\n    pets: typing.List[str]\n    accounts: typing.Dict[str, int]\n    favorite_colors: types.Enum = types.Enum([\"BLUE\", \"YELLOW\", \"GREEN\"])\n    country: str = \"Argentina\"\n    address: str = None\n\nSchemaGenerator(User).avro_schema()\n\n# New versions\nfrom dataclasses_avroschema import AvroModel, types\n\n\nclass User(AvroModel):\n    \"An User\"\n    name: str\n    age: int\n    pets: typing.List[str]\n    accounts: typing.Dict[str, int]\n    favorite_colors: types.Enum = types.Enum([\"BLUE\", \"YELLOW\", \"GREEN\"])\n    country: str = \"Argentina\"\n    address: str = None\n\nUser.avro_schema()\n</code></pre> <p>Another changes introduced was the way that extra avro attributes are represented, like <code>namespace</code>, <code>aliases</code> and whether to include <code>avro documentation</code>:</p> <pre><code>class User:\n    \"My User Class\"\n    name: str\n    age: int\n    has_pets: bool = False\n    money: float = 100.3\n\n    def extra_avro_attributes() -&gt; typing.Dict[str, typing.Any]:\n        return {\n            \"namespace\": \"test.com.ar/user/v1\",\n            \"aliases\": [\"User\", \"My favorite User\"]\n        }\n\nSchemaGenerator(User, include_schema_doc=False).avro_schema()\n\n# Now is perform using a Meta class\n\nclass User(AvroModel):\n    \"My User Class\"\n    name: str\n    age: int\n    has_pets: bool = False\n    money: float = 100.3\n\n    class Meta:\n        schema_doc = False\n        namespace = \"test.com.ar/user/v1\"\n        aliases = [\"User\", \"My favorite User\"]\n</code></pre>"},{"location":"primitive_types/","title":"Primitive Types","text":"<p>The following list represent the avro primitive types mapped to python types:</p>    Avro Type Python Type     string str   int,long int   boolean bool   float,double float   null None   bytes bytes"},{"location":"primitive_types/#examples","title":"Examples","text":"Primitive types<pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel, types\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"An User\"\n    name: str\n    age: int\n    height: types.Float32\n    weight: types.Int32\n    is_student: bool\n    money_available: float\n    encoded: bytes\n\n\nUser.avro_schema()\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"age\",\n      \"type\": \"long\"\n    },\n    {\n      \"name\": \"height\",\n      \"type\": \"float\"\n    },\n    {\n      \"name\": \"weight\",\n      \"type\": \"int\"\n    },\n    {\n      \"name\": \"is_student\",\n      \"type\": \"boolean\"\n    },\n    {\n      \"name\": \"money_available\",\n      \"type\": \"double\"\n    },\n    {\n        \"name\": \"encoded\",\n        \"type\": \"bytes\"\n    }\n  ],\n  \"doc\": \"An User\"\n}\n</code></pre>"},{"location":"primitive_types/#examples-with-null","title":"Examples with <code>null</code>","text":"<pre><code>import dataclasses\nfrom typing import Optional\n\nfrom dataclasses_avroschema import AvroModel, types\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"An User\"\n    name: Optional[str] = None\n    age: Optional[int] = None\n    height: Optional[types.Float32] = None\n    weight: Optional[types.Int32] = None\n    is_student: Optional[bool] = None\n    money_available: Optional[float] = None\n    encoded: Optional[bytes] = None\n\n\nUser.avro_schema()\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": [\"null\", \"string\"],\n      \"default\": null\n    },\n    {\n      \"name\": \"age\",\n      \"type\": [\"null\", \"long\"],\n      \"default\": null\n    },\n    {\n      \"name\": \"height\",\n      \"type\": [\"null\", \"float\"],\n      \"default\": null\n    },\n    {\n      \"name\": \"weight\",\n      \"type\": [\"null\", \"int\"],\n      \"default\": null\n    },\n    {\n      \"name\": \"is_student\",\n      \"type\": [\"null\", \"boolean\"],\n      \"default\": null\n    },\n    {\n      \"name\": \"money_available\",\n      \"type\": [\"null\", \"double\"],\n      \"default\": null\n    },\n    {\n      \"name\": \"encoded\",\n      \"type\": [\"null\", \"bytes\"],\n      \"default\": null\n    }\n  ],\n  \"doc\": \"An User\"\n}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"primitive_types/#examples-with-default-values","title":"Examples with default values","text":"<pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel, types\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"An User\"\n    name: str = 'Juan'\n    age: int = 20\n    height: types.Float32 = 165.3\n    weight: types.Int32 = 72\n    is_student: bool = True\n    money_available: float = 100.2\n    encoded: bytes = b\"hi\"\n\n\nUser.avro_schema()\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\",\n      \"default\": \"Juan\"\n    },\n    {\n      \"name\": \"age\",\n      \"type\": \"long\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"height\",\n      \"type\": [\"null\", \"float\"],\n      \"default\": 165.3\n    },\n    {\n      \"name\": \"weight\",\n      \"type\": [\"null\", \"int\"],\n      \"default\": 72\n    },\n    {\n      \"name\": \"is_student\",\n      \"type\": \"boolean\",\n      \"default\": true\n    },\n    {\n      \"name\": \"money_available\",\n      \"type\": \"double\",\n      \"default\": 100.2\n    },\n    {\n        \"name\": \"encoded\",\n        \"type\": \"bytes\",\n        \"default\": \"hi\"\n    }\n  ],\n  \"doc\": \"An User\"\n}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"pydantic/","title":"Pydantic Integration","text":"<p>It is possible to use pydantic with <code>dataclasses-avroschema</code> making use of <code>AvroBaseModel</code>:</p> <p>You must use use all the <code>pydantic</code> features and all <code>dataclasses-avroschema</code> functionality will be injected.</p>  <p>Note</p> <p>With <code>pydantic</code> you do not have to use <code>python dataclasses</code></p>"},{"location":"pydantic/#avro-and-json-schemas","title":"Avro and Json schemas","text":"Basic usage<pre><code>import typing\nimport enum\nfrom dataclasses_avroschema.avrodantic import AvroBaseModel\n\nfrom pydantic import Field\n\n\nclass FavoriteColor(str, enum.Enum):\n    BLUE = \"BLUE\"\n    YELLOW = \"YELLOW\"\n    GREEN = \"GREEN\"\n\n\nclass UserAdvance(AvroBaseModel):\n    name: str\n    age: int\n    pets: typing.List[str] = Field(default_factory=lambda: [\"dog\", \"cat\"])\n    accounts: typing.Dict[str, int] = Field(default_factory=lambda: {\"key\": 1})\n    has_car: bool = False\n    favorite_colors: FavoriteColor = FavoriteColor.BLUE\n    country: str = \"Argentina\"\n    address: str = None\n\n    class Meta:\n        schema_doc = False\n\n\n# Avro schema\nUserAdvance.avro_schema()\n'{\n    \"type\": \"record\",\n    \"name\": \"UserAdvance\",\n    \"fields\": [\n        {\"name\": \"name\", \"type\": \"string\"},\n        {\"name\": \"age\", \"type\": \"long\"},\n        {\"name\": \"pets\", \"type\": {\"type\": \"array\", \"items\": \"string\", \"name\": \"pet\"}, \"default\": [\"dog\", \"cat\"]},\n        {\"name\": \"accounts\", \"type\": {\"type\": \"map\", \"values\": \"long\", \"name\": \"account\"}, \"default\": {\"key\": 1}},\n        {\"name\": \"has_car\", \"type\": \"boolean\", \"default\": false},\n        {\"name\": \"favorite_colors\", \"type\": {\"type\": \"enum\", \"name\": \"FavoriteColor\", \"symbols\": [\"BLUE\", \"YELLOW\", \"GREEN\"]}, \"default\": \"BLUE\"},\n        {\"name\": \"country\", \"type\": \"string\", \"default\": \"Argentina\"},\n        {\"name\": \"address\", \"type\": [\"null\", \"string\"], \"default\": null}\n    ]\n}'\n\n# Json schema\nUserAdvance.json_schema()\n\n'{\n    \"title\": \"UserAdvance\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"name\": {\"title\": \"Name\", \"type\": \"string\"},\n        \"age\": {\"title\": \"Age\", \"type\": \"integer\"},\n        \"pets\": {\"title\": \"Pets\", \"type\": \"array\", \"items\": {\"type\": \"string\"}},\n        \"accounts\": {\"title\": \"Accounts\", \"type\": \"object\", \"additionalProperties\": {\"type\": \"integer\"}},\n        \"has_car\": {\"title\": \"Has Car\", \"default\": false, \"type\": \"boolean\"},\n        \"favorite_colors\": {\"default\": \"BLUE\", \"allOf\": [{\"$ref\": \"#/definitions/FavoriteColor\"}]},\n        \"country\": {\"title\": \"Country\", \"default\": \"Argentina\", \"type\": \"string\"},\n        \"address\": {\"title\": \"Address\", \"type\": \"string\"}},\n        \"required\": [\"name\", \"age\"], \"definitions\": {\"FavoriteColor\": {\"title\": \"FavoriteColor\", \"description\": \"An enumeration.\", \"enum\": [\"BLUE\", \"YELLOW\", \"GREEN\"], \"type\": \"string\"}}}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>  <p>Note</p> <p>You must use pydantic.Field instead of dataclasses.field</p>"},{"location":"pydantic/#pydantic-and-dataclasses_avroschema-batteries","title":"Pydantic and dataclasses_avroschema batteries","text":""},{"location":"pydantic/#to-dict-to-json-and-serialization","title":"To dict, to json and serialization","text":"getting dict and json<pre><code>user = UserAdvance(name=\"bond\", age=50)\n\n# to_json from dataclasses-avroschema is the same that json from pydantic\nassert user.to_json() == user.json()\n\n# to_dict from dataclasses-avroschema is the same that dict from pydantic\nassert user.to_dict() == user.dict()\n</code></pre> serialization<pre><code>event = user.serialize()\nprint(event)\n# &gt;&gt;&gt; b'\\x08bondd\\x04\\x06dog\\x06cat\\x00\\x02\\x06key\\x02\\x00\\x00\\x00\\x12Argentina\\x00'\n\nUserAdvance.deserialize(data=event)\n# &gt;&gt;&gt; UserAdvance(name='bond', age=50, pets=['dog', 'cat'], accounts={'key': 1}, has_car=False, favorite_colors=&lt;FavoriteColor.BLUE: 'BLUE'&gt;, country='Argentina', address=None)\n</code></pre>"},{"location":"pydantic/#parsing-objects","title":"Parsing Objects","text":"parse_obj usage<pre><code>import typing\n\nfrom dataclasses_avroschema.avrodantic import AvroBaseModel\n\n\nclass Address(AvroBaseModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\nclass User(AvroBaseModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    addresses: typing.List[Address]\n\ndata_user = {\n    \"name\": \"john\",\n    \"age\": 20,\n    \"addresses\": [{\n        \"street\": \"test\",\n        \"street_number\": 10,\n        }],\n    }\n\nuser = User.parse_obj(data=data_user)\nassert type(user.addresses[0]) is Address\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> parse_obj_as usage<pre><code>from typing import List\n\nfrom pydantic import parse_obj_as\n\nfrom dataclasses_avroschema.avrodantic import AvroBaseModel\n\n\nclass User(AvroBaseModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n\n\ndata = [{\"name\": \"bond\", \"age\": 50}, {\"name\": \"bond2\", \"age\": 60}]\nusers = parse_obj_as(List[User], data)\n\nusers[0].avro_schema()\n# '{\"type\": \"record\", \"name\": \"User\", \"fields\": [{\"name\": \"name\", \"type\": \"string\"}, {\"name\": \"age\", \"type\": \"long\"}], \"doc\": \"User with multiple Address\"}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"pydantic/#fake","title":"Fake","text":"<p>It is also possible to create <code>fake</code> instances with <code>pydantic</code> models:</p> <pre><code>import typing\nimport datetime\nfrom pydantic import Field\nfrom dataclasses_avroschema.avrodantic import AvroBaseModel\n\n\nclass User(AvroBaseModel):\n    name: str\n    age: int\n    birthday: datetime.date\n    pets: typing.List[str] = Field(default_factory=lambda: [\"dog\", \"cat\"])\n    accounts: typing.Dict[str, int] = Field(default_factory=lambda: {\"key\": 1})\n    has_car: bool = False\n\nprint(User.fake())\n# &gt;&gt;&gt; User(name='qWTLkqcIVmSBxpWMpFyR', age=2608, birthday=datetime.date(1982, 3, 30), pets=['wqoEXcJRYjcnJmnIvtiI'], accounts={'JueNdHdzIhHIDsjlHJLc': 779}, has_car=True)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"records/","title":"Records","text":"<p>Mapped as a Python class. There are some special avro attributes like <code>aliases</code>, <code>namespace</code> and <code>doc</code> (both not required) that can be specified in a record type.</p> <p>The <code>doc</code> attribute can be set via the docstring class. The <code>aliases</code> and <code>namespaces</code> must be set using <code>Class Meta</code>.</p>"},{"location":"records/#basic-usage","title":"Basic usage","text":"<pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"My User Class\"\n    name: str\n    age: int\n    has_pets: bool = False\n    money: float = 100.3\n\n    class Meta:\n        namespace = \"test.com.ar/user/v1\"\n        aliases = [\"User\", \"My favorite User\"]\n\nUser.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"has_pets\", \"type\": \"boolean\", \"default\": false},\n    {\"name\": \"money\", \"type\": \"double\", \"default\": 100.3}\n  ],\n  \"doc\": \"My User Class\",\n  \"namespace\": \"test.com.ar/user/v1\",\n  \"aliases\": [\"User\", \"My favorite User\"]\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"records/#class-meta","title":"Class Meta","text":"<p>The <code>class Meta</code> is used to specify schema attributes that are not represented by the class fields like <code>namespace</code>, <code>aliases</code> and whether to include the <code>schema documentation</code>. One can also provide a custom schema name (the default is the class' name) via <code>schema_name</code> attribute and <code>alias_nested_items</code> when you have nested items and you want to use custom naming for them.</p> Class Meta description<pre><code>class Meta:\n    schema_name = \"Name other than the class name\"\n    schema_doc = False\n    namespace = \"test.com.ar/user/v1\"\n    aliases = [\"User\", \"My favorite User\"]\n    alias_nested_items = {\"address\": \"Address\"}\n</code></pre> <p><code>schema_doc (Union[boolean, str])</code>: Whether include the <code>schema documentation</code> generated from <code>docstrings</code>. Default <code>True</code>. If the value is a <code>string</code> if will be used to generate the schema documentation.</p> <p><code>namespace (optional[str])</code>: Schema namespace. Default <code>None</code></p> <p><code>aliases (optional[List[str]])</code>: Schema aliases. Default <code>None</code></p> <p><code>alias_nested_items (optional[Dict[str, str]])</code>: Nested items names</p>"},{"location":"records/#record-to-json-and-dict","title":"Record to json and dict","text":"<p>You can get the <code>json</code> and <code>dict</code> representation of your instance using <code>to_json</code> and <code>to_dict</code> methods:</p> Json and Dict example<pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"My User Class\"\n    name: str\n    age: int\n    has_pets: bool = False\n    money: float = 100.3\n\n\nuser = User(name=\"Bond\", age=50)\n\nuser.to_json()\n# &gt;&gt;&gt; '{\"name\": \"Bond\", \"age\": 50, \"has_pets\": false, \"money\": 100.3}'\n\nuser.to_dict()\n# &gt;&gt;&gt; {'name': 'Bond', 'age': 50, 'has_pets': False, 'money': 100.3}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"records/#validation","title":"Validation","text":"<p>Python classes that inheritance from <code>AvroModel</code> has a <code>validate</code> method. This method <code>validates</code> whether the instance data matches the schema that it represents, for example:</p> Validation example<pre><code>from dataclasses import dataclass\n\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclass\nclass User(AvroModel):\n    name: str\n    age: int\n    has_pets: bool\n    money: float\n    encoded: bytes\n\n# this creates a proper instance\nuser_instance = User(\n    name=\"a name\",\n    age=10,\n    has_pets=True,\n    money=0,\n    encoded=b'hi',\n)\nassert user_instance.validate()\n\n# set 1 to the name attribute and the fastavro validation should fail\n# This is possible because in dataclasses there is not restriction,\n# but at the moment of using pydantic this will change\nuser_instance.name = 1\nwith pytest.raises(ValidationError) as exc:\n    assert user_instance.validate()\n\nassert json.loads(str(exc.value)) == [\"User.name is &lt;1&gt; of type &lt;class 'int'&gt; expected string\"]\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"records/#nested-schema-resolution-directly-from-dictionaries","title":"Nested schema resolution directly from dictionaries","text":"<p>Sometimes you have a <code>dictionary</code> and you want to create an instance without creating the nested objects. This library follows the same approach as <code>pydantic</code> with <code>parse_obj</code> method. This is also valid for <code>avrodantic.AvroBaseModel</code>.</p> <pre><code>from dataclasses import dataclass\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclass\nclass Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n@dataclass\nclass User(AvroModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    addresses: typing.List[Address]\n\ndata_user = {\n    \"name\": \"john\",\n    \"age\": 20,\n    \"addresses\": [{\n        \"street\": \"test\",\n        \"street_number\": 10,\n        }],\n    }\n\nuser = User.parse_obj(data=data_user)\nassert type(user.addresses[0]) is Address\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"records/#class-inheritance","title":"Class inheritance","text":"<p>It is possible to have inheritance so you do not have to repeat the same code. You need to be aware that parent classes might have attributes with default values and that can cause <code>TypeError: non-default argument</code> errors.</p>  <p>Hint</p> <p>With Python 3.10, it is now possible to do it natively with dataclasses. Dataclasses 3.10 added the <code>kw_only</code> attribute (similar to attrs). It allows you to specify which fields are keyword_only, thus will be set at the end of the init, not causing an inheritance problem.</p>  <pre><code>from dataclasses import dataclass\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclass\nclass Parent(AvroModel):\n    name: str\n    age: int\n\n\n@dataclass\nclass Child(Parent):\n    has_pets: bool\n    money: float\n    encoded: bytes\n\n\n@dataclass\nclass Child2(Parent, AvroModel):\n    has_pets: bool\n    money: float\n    encoded: bytes\n\n    class Meta:\n        schema_doc = False\n\nChild2.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"Child2\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"has_pets\", \"type\": \"boolean\", \"default\": false},\n    {\"name\": \"money\", \"type\": \"double\", \"default\": 100.3},\n    {\"name\": \"encoded\", \"type\": \"bytes\"}\n  ]\n}'\n\n\nassert child_schema[\"fields\"] == child_2_schema[\"fields\"]\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"redis_examples/","title":"Redis examples","text":"<p>Minimal redis example using <code>redis streams</code> with walrus driver.</p> Example with walrus driver<pre><code>from dataclasses import dataclass\nimport enum\nimport random\nfrom time import sleep\n\nfrom walrus import Database  # A subclass of the redis-py Redis client.\n\nfrom dataclasses_avroschema import AvroModel, types\n\n\nclass FavoriteColor(enum.Enum):\n    BLUE = \"Blue\"\n    YELLOW = \"Yellow\"\n    GREEN = \"Green\"\n\n@dataclass\nclass UserModel(AvroModel):\n    \"An User\"\n    name: str\n    age: int\n    favorite_colors: FavoriteColor = FavoriteColor.BLUE\n    country: str = \"Argentina\"\n    address: str = None\n    testing: bool = False\n\n    class Meta:\n        namespace = \"User.v1\"\n        aliases = [\"user-v1\", \"super user\"]\n\n\ndef consume(consumer_group):\n    # read new messages in the stream\n\n    while True:\n        result = consumer_group.my_stream.read(count=1, block=1000)\n        # Each record has the followinf format\n        # [(b'1598545738231-0', {b'message': b'\\x06KimT\\x00\\x12Argentina\\x00\\x00'})]\n\n        if result:\n            message_id, message_content = result[0]\n\n            if message_id:\n                value = message_content[b'message']\n                print(f\"Processing message {message_id} with value {value}\")\n                user = UserModel.deserialize(value)\n                print(user)\n\n\ndef produce(consumer_group):\n    for i in range(10):\n        # create an instance of User v1\n        user = UserModel(\n            name=random.choice([\"Juan\", \"Peter\", \"Michael\", \"Moby\", \"Kim\",]),\n            age=random.randint(1, 50)\n        )\n\n        msgid = consumer_group.my_stream.add({\"message\": user.serialize()})\n        print(f\"Producing message {msgid}\")\n\n    print(\"Producer finished....\")\n    print(\"#\" * 80)\n    sleep(2)\n\n\nif __name__ == \"__main__\":\n    db = Database()\n    stream_name = 'my-stream'\n    db.Stream(stream_name)  # Create a new stream instance\n\n    # create the consumer group\n    consumer_group = db.consumer_group('my-consumer-group-1', [stream_name])\n    consumer_group.create()  # Create the consumer group.\n    consumer_group.set_id('$')\n\n    produce(consumer_group)\n    consume(consumer_group)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"schema_relationships/","title":"Schema Relationships","text":""},{"location":"schema_relationships/#onetoone","title":"OneToOne","text":"An User has one Address example<pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\nclass User(AvroModel):\n    \"An User with Address\"\n    name: str\n    age: int\n    address: Address\n\nUser.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"address\", \"type\": {\n      \"type\": \"record\",\n      \"name\": \"Address\",\n      \"fields\": [\n        {\"name\": \"street\",\"type\": \"string\"},\n        {\"name\": \"street_number\", \"type\": \"long\"}\n      ],\n      \"doc\": \"An Address\"\n      }\n    }\n  ],\n  \"doc\": \"An User with Address\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"schema_relationships/#onetoone-recursive-schema-relationship","title":"OneToOne Recursive Schema Relationship","text":"An User with only one friend :-(<pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"User with self reference as friend\"\n    name: str\n    age: int\n    friend: typing.Type[\"User\"] = None\n\nUser.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"age\",\n      \"type\": \"long\"\n    },\n    {\n      \"name\": \"friend\",\n      \"type\": [\"null\", \"User\"],\n      \"default\": null\n    }\n  ],\n  \"doc\": \"User with self reference as friend\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"schema_relationships/#onetomany-schema-relationship","title":"OneToMany Schema Relationship","text":"An User has multiple Address example<pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    addresses: typing.List[Address]\n\n\nUser.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"addresses\", \"type\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"record\",\n          \"name\": \"Address\",\n          \"fields\": [\n            {\"name\": \"street\", \"type\": \"string\"},\n            {\"name\": \"street_number\", \"type\": \"long\"}\n          ],\n          \"doc\": \"An Address\"\n        },\n        \"name\": \"address\"\n      }\n    }\n  ],\n  \"doc\": \"User with multiple Address\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> OneToMany with Map example<pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    addresses: typing.Dict[str, Address]\n\n\nUser.avro_schema()\n\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\"name\": \"name\", \"type\": \"string\"},\n    {\"name\": \"age\", \"type\": \"long\"},\n    {\"name\": \"addresses\", \"type\": {\n        \"type\": \"map\",\n        \"values\": {\n          \"type\": \"record\",\n          \"name\": \"Address\",\n          \"fields\": [\n            {\"name\": \"street\", \"type\": \"string\"},\n            {\"name\": \"street_number\", \"type\": \"long\"}\n          ],\n          \"doc\": \"An Address\"\n        },\n        \"name\": \"address\"\n      }\n    }\n  ],\n  \"doc\": \"User with multiple Address\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"schema_relationships/#onetomany-recursive-schema-relationship","title":"OneToMany Recursive Schema Relationship","text":"OneToMany recursive example<pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n# Using a List (Avro Array)\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"User with self reference as friends\"\n    name: str\n    age: int\n    friends: typing.List[typing.Type[\"User\"]] = None\n\n\nUser.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"age\",\n      \"type\": \"long\"\n    },\n    {\n      \"name\": \"friends\",\n      \"type\": {\n        \"type\": \"array\",\n        \"items\": \"User\",\n        \"name\": \"friend\"\n      },\n      \"default\": []\n    }\n  ],\n  \"doc\": \"User with self reference as friends\"\n}'\n\n# Using a Dict (Avro Map)\n@dataclasses.dataclass\nclass User(AvroModel):\n  \"User with self reference as friends\"\n  name: str\n  age: int\n  friends: typing.Dict[str, typing.Type[\"User\"]] = None\n\nUser.avro_schema()\n\n'{\n  \"type\": \"record\",\n  \"name\": \"User\",\n  \"fields\": [\n    {\n      \"name\": \"name\",\n      \"type\": \"string\"\n    },\n    {\n      \"name\": \"age\",\n      \"type\": \"long\"\n    },\n    {\n      \"name\": \"friends\",\n      \"type\": {\n        \"type\": \"map\",\n        \"values\": \"User\",\n        \"name\": \"friend\"\n      },\n      \"default\": {}\n    }\n  ],\n  \"doc\": \"User with self reference as friends\"\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"schema_relationships/#avoid-name-collision-in-multiple-relationships","title":"Avoid name collision in multiple relationships","text":"<p>Sometimes we have relationships where a class is related more than once with a particular class, and the name for the nested schemas must be different, otherwise we will generate an invalid <code>avro schema</code>. For those cases, you MUST define the <code>namespace</code>.</p> Avoiding name collision example<pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nimport json\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclass\nclass Location(AvroModel):\n    latitude: float\n    longitude: float\n\n    class Meta:\n        namespace = \"types.location_type\"\n\n@dataclass\nclass Trip(AvroModel):\n    start_time: datetime\n    start_location: Location  # first relationship\n    finish_time: datetime\n    finish_location: Location  # second relationship\n\n\nTrip.avro_schema()\n</code></pre> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"Trip\",\n  \"fields\": [\n    {\n      \"name\": \"start_time\",\n      \"type\": {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}\n    },\n    {\n      \"name\": \"start_location\",\n      \"type\": {\"type\": \"record\",\n      \"name\": \"Location\",\n        \"fields\": [\n          {\"name\": \"latitude\", \"type\": \"double\"},\n          {\"name\": \"longitude\", \"type\": \"double\"}\n        ],\n      \"doc\": \"Location(latitude: float, longitude: float)\",\n      \"namespace\": \"types.location_type\"}},\n    {\n      \"name\": \"finish_time\",\n      \"type\": {\"type\": \"long\", \"logicalType\": \"timestamp-millis\"}\n    },\n    {\n      \"name\": \"finish_location\", \"type\": \"types.location_type.Location\"  // using the namespace\n    }\n  ],\n  \"doc\": \"Trip(start_time: datetime.datetime, start_location: __main__.Location, finish_time: datetime.datetime, finish_location: __main__.Location)\"\n}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>or with <code>arrays</code> or <code>maps</code>:</p> <pre><code>@dataclasses.dataclass\nclass Location(AvroModel):\n    latitude: float\n    longitude: float\n\n    class Meta:\n        namespace = \"types.location_type\"\n        schema_doc = False\n\n\n@dataclasses.dataclass\nclass Trip(AvroModel):\n    start_location: Location\n    finish_location: typing.List[Location]\n\n    class Meta:\n        schema_doc = False\n\n\nTrip.avro_schema()\n</code></pre> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"Trip\",\n  \"fields\": [\n    {\n      \"name\": \"start_location\",\n      \"type\":\n        {\n          \"type\": \"record\",\n          \"name\": \"Location\",\n          \"fields\": [\n            {\n              \"name\": \"latitude\",\n              \"type\": \"double\"\n            },\n            {\n              \"name\": \"longitude\",\n              \"type\": \"double\"\n            }\n          ],\n          \"namespace\": \"types.location_type\"\n        }\n      },\n    {\n      \"name\": \"finish_location\",\n      \"type\": {\n        \"type\": \"array\",\n        \"items\": \"types.location_type.Location\",\n        \"name\": \"finish_location\"\n      }\n    }\n  ]\n}'\n</code></pre> <pre><code>@dataclasses.dataclass\nclass Location(AvroModel):\n    latitude: float\n    longitude: float\n\n    class Meta:\n        namespace = \"types.location_type\"\n        schema_doc = False\n\n\n@dataclasses.dataclass\nclass Trip(AvroModel):\n    start_location: Location\n    finish_location: typing.Dict[str, Location]\n\n    class Meta:\n        schema_doc = False\n\n\nTrip.avro_schema()\n</code></pre> <pre><code>{\n  \"type\": \"record\",\n  \"name\": \"Trip\",\n  \"fields\": [\n    {\n      \"name\": \"start_location\",\n      \"type\": {\n        \"type\": \"record\",\n        \"name\": \"Location\",\n        \"fields\": [\n          {\n            \"name\": \"latitude\",\n            \"type\": \"double\"\n          },\n          {\n            \"name\": \"longitude\",\n            \"type\": \"double\"\n          }\n        ],\n        \"namespace\": \"types.location_type\"\n      }\n    },\n    {\n      \"name\": \"finish_location\",\n      \"type\": {\n        \"type\": \"map\",\n        \"values\": \"types.location_type.Location\",\n        \"name\": \"finish_location\"\n      }\n    }\n  ]\n}'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>If you want, also you can use custom name for nested items (<code>nested records</code>, <code>arrays</code> or <code>maps</code>) using the property <code>alias_nested_items</code> in <code>class Meta</code>:</p> <pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"An User with Address\"\n    name: str\n    age: int\n    address: Address  # default name Address\n\n    class Meta:\n        alias_nested_items = {\"address\": \"MySuperAddress\"}\n</code></pre> <p><code>User.avro_schema()</code> will generate:</p> <pre><code>{\n    \"type\": \"record\",\n    \"name\": \"User\",\n    \"fields\": [\n        {\n            \"name\": \"name\",\n            \"type\": \"string\"\n        },\n        {\n            \"name\": \"age\",\n            \"type\": \"long\"\n        },\n        {\n            \"name\": \"address\",\n            \"type\": {\n                \"type\": \"record\",\n                \"name\": \"MySuperAddress\",  // renamed it using alias_nested_items\n                \"fields\": [\n                    {\n                        \"name\": \"street\",\n                        \"type\": \"string\"\n                    },\n                    {\n                        \"name\": \"street_number\",\n                        \"type\": \"long\"\n                    }\n                ],\n                \"doc\": \"An Address\"\n            }\n        } \n    ],\n    \"doc\": \"An User with Address\"\n}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"serialization/","title":"Serialization","text":"<p>Is possible to <code>serialize/deserialize</code> with the correspondent avro schema generated and the dataclass. In both cases we can do it with <code>avro</code> or <code>avro-json</code>.</p>"},{"location":"serialization/#instances-serialization","title":"Instances serialization","text":"Avro and avro-json serialization<pre><code>from dataclasses import dataclass\nimport typing\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclass\nclass Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\n@dataclass\nclass User(AvroModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    addresses: typing.List[Address]\n\naddress_data = {\n    \"street\": \"test\",\n    \"street_number\": 10,\n}\n\n# create an Address instance\naddress = Address(**address_data)\n\ndata_user = {\n    \"name\": \"john\",\n    \"age\": 20,\n    \"addresses\": [address],\n}\n\n# create an User instance\nuser = User(**data_user)\n\nuser.serialize()\n# &gt;&gt;&gt; b\"\\x08john(\\x02\\x08test\\x14\\x00\"\n\nuser.serialize(serialization_type=\"avro-json\")\n# &gt;&gt;&gt; b'{\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]}'\n\nuser.to_json()\n# python dict &gt;&gt;&gt; {'name': 'john', 'age': 20, 'addresses': [{'street': 'test', 'street_number': 10}]}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>  <p>Note</p> <p>For serialization is neccesary to use python <code>dataclasses</code></p>"},{"location":"serialization/#deserialization","title":"Deserialization","text":"<p>Deserialization could take place with an instance dataclass or the dataclass itself. Can return the dict representation or a new class instance.</p> Avro and avro-json deserialization<pre><code>import typing\nimport dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass Address(AvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n\n\n@dataclasses.dataclass\nclass User(AvroModel):\n    \"User with multiple Address\"\n    name: str\n    age: int\n    addresses: typing.List[Address]\n\navro_binary = b\"\\x08john(\\x02\\x08test\\x14\\x00\"\navro_json_binary = b'{\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]}'\n\n# return a new class instance!!\nUser.deserialize(avro_binary)\n# &gt;&gt;&gt; User(name='john', age=20, addresses=[Address(street='test', street_number=10)])\n\n# return a python dict\nUser.deserialize(avro_binary, create_instance=False)\n# &gt;&gt;&gt; {\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]}\n\n# return a new class instance!!\nUser.deserialize(avro_json_binary, serialization_type=\"avro-json\")\n# &gt;&gt;&gt; User(name='john', age=20, addresses=[Address(street='test', street_number=10)])\n\n# return a python dict\nUser.deserialize(avro_json_binary, serialization_type=\"avro-json\", create_instance=False)\n# &gt;&gt;&gt; {\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]}\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"serialization/#deserialization-using-a-different-schema","title":"Deserialization using a different schema","text":"<p>To deserialize data encoded via a different schema, one can pass an optional <code>writer_schema: AvroModel | dict[str, Any]</code> attribute. It will be used by the fastavros <code>schemaless_reader</code>.</p> Deserialization with different schemas<pre><code>@dataclass\nclass User(AvroModel):\n    name: str\n    age: int\n\n\n@dataclass\nclass UserCompatible(AvroModel):\n    name: str\n    age: int\n    nickname: Optional[str] = None\n\n    class Meta:\n        schema_name = \"User\"\n\n\nuser_data = {\n    \"name\": \"G.R. Emlin\",\n    \"age\": 52,\n}\n\n# serialize data with the User schema\n&gt;&gt;&gt; serialized_user = User(**user_data).serialize()\n\n# deserialize user using a new, but compatible schema\n&gt;&gt;&gt; deserialized_user = UserCompatible.deserialize(serialized_user, writer_schema=User)\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"},{"location":"serialization/#custom-serialization","title":"Custom Serialization","text":"<p>The <code>serialization/deserialization</code> process is built over fastavro. If you want to use another library or a different process, you can override the base <code>AvroModel</code>:</p> Custom serialization<pre><code>import dataclasses\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass MyAvroModel(AvroModel):\n\n    ...\n\n    def serialize(self, serialization_type: str = AVRO) -&gt; bytes:\n        # Get the schema as a python dict\n        schema = self.avro_schema_to_python()\n\n        # instance as python dict\n        data = self.asdict()\n\n        # call your custom serialization withe the avro schema and the data\n        return custom_serialization(schema, datam serialization_type=serialization_type)\n\n    @classmethod\n    def deserialize(\n        cls, data: bytes, serialization_type: str = AVRO, create_instance: bool = True\n    ) -&gt; typing.Union[typing.Dict, \"AvroModel\"]:\n        # Get the schema as a python dict\n        schema = cls.avro_schema_to_python()\n\n        # get the python dict with the schema and the data (bytes)\n        payload = custom_deserialize(data, schema, serialization_type=serialization_type)\n\n        if create_instance:\n            return from_dict(data_class=cls, data=payload, config=Config(check_types=False))\n        return payload\n\n\n# and then inherits from your custom AvroModel\n\n@dataclasses.dataclass\nclass Address(MyAvroModel):\n    \"An Address\"\n    street: str\n    street_number: int\n</code></pre>"},{"location":"serialization/#encoding-for-unions-with-avro-json","title":"Encoding for unions with avro-json","text":"<p>When you have an <code>union</code> and you want to serialize a <code>payload</code> using <code>avro-json</code> you will notice that the <code>type</code> is added to each <code>union</code> field. This is needed because after the serialization process you need to know the <code>type</code> in order to <code>deserialize</code>:</p>  <p>Do not confuse json with avro-json!!</p>  Union encoding with avro-json example<pre><code>import typing\nimport dataclasses\nimport datetime\nimport uuid\n\nfrom dataclasses_avroschema import AvroModel\n\n\n@dataclasses.dataclass\nclass UnionSchema(AvroModel):\n    \"Some Unions\"\n    first_union: typing.Union[str, int]\n    logical_union: typing.Union[datetime.datetime, datetime.date, uuid.uuid4]\n\n\nmy_union = UnionSchema(first_union=10, logical_union=datetime.datetime.now())\n\n\nevent = my_union.serialize(serialization_type=\"avro-json\")\n\nprint(event)\n# long is added to each field\n&gt;&gt;&gt; b'{\"first_union\": {\"long\": 10}, \"logical_union\": {\"long\": 1647971584847}}'\n\nmy_union.deserialize(event, serialization_type=\"avro-json\")\n# &gt;&gt;&gt; UnionSchema(first_union=10, logical_union=datetime.datetime(2022, 3, 22, 17, 53, 4, 847000, tzinfo=datetime.timezone.utc))\n\n\n# bad data\nevent_2 = b'{\"first_union\": 10, \"logical_union\": {\"long\": 1647971584847}}'\n\nmy_union.deserialize(event_2, serialization_type=\"avro-json\")\n\nFile ~/Projects/dataclasses-avroschema/.venv/lib/python3.8/site-packages/fastavro/io/json_decoder.py:213, in AvroJSONDecoder.read_index(self)\n    211     label = \"null\"\n    212 else:\n--&gt; 213     label, data = self._current[self._key].popitem()\n    214     self._current[self._key] = data\n    215     # TODO: Do we need to do this?\n\nAttributeError: 'int' object has no attribute 'popitem'\n</code></pre> <p>(This script is complete, it should run \"as is\")</p>"}]}